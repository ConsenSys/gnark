// Copyright 2020 ConsenSys AG
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package groth16 implements Groth16 zkSNARK workflow (https://eprint.iacr.org/2016/260.pdf)
package groth16

import (
	"io"

	"github.com/consensys/gurvy"

	"github.com/consensys/gnark/backend"
	"github.com/consensys/gnark/frontend"
	backend_bls377 "github.com/consensys/gnark/internal/backend/bls377/r1cs"
	backend_bls381 "github.com/consensys/gnark/internal/backend/bls381/r1cs"
	backend_bn256 "github.com/consensys/gnark/internal/backend/bn256/r1cs"
	backend_bw761 "github.com/consensys/gnark/internal/backend/bw761/r1cs"

	witness_bls377 "github.com/consensys/gnark/internal/backend/bls377/witness"
	witness_bls381 "github.com/consensys/gnark/internal/backend/bls381/witness"
	witness_bn256 "github.com/consensys/gnark/internal/backend/bn256/witness"
	witness_bw761 "github.com/consensys/gnark/internal/backend/bw761/witness"

	gnarkio "github.com/consensys/gnark/io"

	groth16_bls377 "github.com/consensys/gnark/internal/backend/bls377/groth16"
	groth16_bls381 "github.com/consensys/gnark/internal/backend/bls381/groth16"
	groth16_bn256 "github.com/consensys/gnark/internal/backend/bn256/groth16"
	groth16_bw761 "github.com/consensys/gnark/internal/backend/bw761/groth16"
)

// Proof represents a Groth16 proof generated by groth16.Prove
//
// it's underlying implementation is curve specific (see gnark/internal/backend)
type Proof interface {
	gnarkio.WriterRawTo
	io.WriterTo
	io.ReaderFrom
}

// ProvingKey represents a Groth16 ProvingKey
//
// it's underlying implementation is curve specific (see gnark/internal/backend)
type ProvingKey interface {
	gnarkio.WriterRawTo
	io.WriterTo
	io.ReaderFrom
	IsDifferent(interface{}) bool
}

// VerifyingKey represents a Groth16 VerifyingKey
//
// it's underlying implementation is curve specific (see gnark/internal/backend)
//
// ExportSolidity is implemented for BN256 and will return an error with other curves
type VerifyingKey interface {
	gnarkio.WriterRawTo
	io.WriterTo
	io.ReaderFrom
	IsDifferent(interface{}) bool
	ExportSolidity(w io.Writer) error
}

// Verify runs the groth16.Verify algorithm on provided proof with given witness
func Verify(proof Proof, vk VerifyingKey, publicWitness frontend.Witness) error {

	switch _proof := proof.(type) {
	case *groth16_bls377.Proof:
		w, err := witness_bls377.Public(publicWitness)
		if err != nil {
			return err
		}
		return groth16_bls377.Verify(_proof, vk.(*groth16_bls377.VerifyingKey), w)
	case *groth16_bls381.Proof:
		w, err := witness_bls381.Public(publicWitness)
		if err != nil {
			return err
		}
		return groth16_bls381.Verify(_proof, vk.(*groth16_bls381.VerifyingKey), w)
	case *groth16_bn256.Proof:
		w, err := witness_bn256.Public(publicWitness)
		if err != nil {
			return err
		}
		return groth16_bn256.Verify(_proof, vk.(*groth16_bn256.VerifyingKey), w)
	case *groth16_bw761.Proof:
		w, err := witness_bw761.Public(publicWitness)
		if err != nil {
			return err
		}
		return groth16_bw761.Verify(_proof, vk.(*groth16_bw761.VerifyingKey), w)
	default:
		panic("unrecognized R1CS curve type")
	}
}

// DeserializeAndVerify behaves like Verify, except the publicWitness is a []byte
// will attempt to decode publicWitness []byte -> fr.Element with the good curve, returns an error if failed.
// publicWitness must be [public] without the one_wire
func DeserializeAndVerify(proof Proof, vk VerifyingKey, publicWitness []byte) error {
	switch _proof := proof.(type) {
	case *groth16_bls377.Proof:
		w, err := witness_bls377.ReadPublic(publicWitness)
		if err != nil {
			return err
		}
		return groth16_bls377.Verify(_proof, vk.(*groth16_bls377.VerifyingKey), w)
	case *groth16_bls381.Proof:
		w, err := witness_bls381.ReadPublic(publicWitness)
		if err != nil {
			return err
		}
		return groth16_bls381.Verify(_proof, vk.(*groth16_bls381.VerifyingKey), w)
	case *groth16_bn256.Proof:
		w, err := witness_bn256.ReadPublic(publicWitness)
		if err != nil {
			return err
		}
		return groth16_bn256.Verify(_proof, vk.(*groth16_bn256.VerifyingKey), w)
	case *groth16_bw761.Proof:
		w, err := witness_bw761.ReadPublic(publicWitness)
		if err != nil {
			return err
		}
		return groth16_bw761.Verify(_proof, vk.(*groth16_bw761.VerifyingKey), w)
	default:
		panic("unrecognized R1CS curve type")
	}
}

// Prove generates the proof of knoweldge of a r1cs with witness.
// if force flag is set, Prove ignores R1CS solving error (ie invalid witness) and executes
// the FFTs and MultiExponentiations to compute an (invalid) Proof object
func Prove(r1cs backend.ConstraintSystem, pk ProvingKey, witness frontend.Witness, force ...bool) (Proof, error) {

	_force := false
	if len(force) > 0 {
		_force = force[0]
	}

	switch _r1cs := r1cs.(type) {
	case *backend_bls377.R1CS:
		w, err := witness_bls377.Full(witness)
		if err != nil {
			return nil, err
		}
		return groth16_bls377.Prove(_r1cs, pk.(*groth16_bls377.ProvingKey), w, _force)
	case *backend_bls381.R1CS:
		w, err := witness_bls381.Full(witness)
		if err != nil {
			return nil, err
		}
		return groth16_bls381.Prove(_r1cs, pk.(*groth16_bls381.ProvingKey), w, _force)
	case *backend_bn256.R1CS:
		w, err := witness_bn256.Full(witness)
		if err != nil {
			return nil, err
		}
		return groth16_bn256.Prove(_r1cs, pk.(*groth16_bn256.ProvingKey), w, _force)
	case *backend_bw761.R1CS:
		w, err := witness_bw761.Full(witness)
		if err != nil {
			return nil, err
		}
		return groth16_bw761.Prove(_r1cs, pk.(*groth16_bw761.ProvingKey), w, _force)
	default:
		panic("unrecognized R1CS curve type")
	}
}

// DeserializeAndProve behaves like Prove, except witness is a []byte
// will attempt to deserialize witness []byte -> fr.Element
// witness []byte must be [secret|one_wire|public]
func DeserializeAndProve(r1cs backend.ConstraintSystem, pk ProvingKey, witness []byte, force ...bool) (Proof, error) {
	_force := false
	if len(force) > 0 {
		_force = force[0]
	}

	switch _r1cs := r1cs.(type) {
	case *backend_bls377.R1CS:
		w, err := witness_bls377.ReadFull(witness)
		if err != nil {
			return nil, err
		}
		return groth16_bls377.Prove(_r1cs, pk.(*groth16_bls377.ProvingKey), w, _force)
	case *backend_bls381.R1CS:
		w, err := witness_bls381.ReadFull(witness)
		if err != nil {
			return nil, err
		}
		return groth16_bls381.Prove(_r1cs, pk.(*groth16_bls381.ProvingKey), w, _force)
	case *backend_bn256.R1CS:
		w, err := witness_bn256.ReadFull(witness)
		if err != nil {
			return nil, err
		}
		return groth16_bn256.Prove(_r1cs, pk.(*groth16_bn256.ProvingKey), w, _force)
	case *backend_bw761.R1CS:
		w, err := witness_bw761.ReadFull(witness)
		if err != nil {
			return nil, err
		}
		return groth16_bw761.Prove(_r1cs, pk.(*groth16_bw761.ProvingKey), w, _force)
	default:
		panic("unrecognized R1CS curve type")
	}
}

// Setup runs groth16.Setup with provided R1CS
func Setup(r1cs backend.ConstraintSystem) (ProvingKey, VerifyingKey, error) {

	switch _r1cs := r1cs.(type) {
	case *backend_bls377.R1CS:
		var pk groth16_bls377.ProvingKey
		var vk groth16_bls377.VerifyingKey
		if err := groth16_bls377.Setup(_r1cs, &pk, &vk); err != nil {
			return nil, nil, err
		}
		return &pk, &vk, nil
	case *backend_bls381.R1CS:
		var pk groth16_bls381.ProvingKey
		var vk groth16_bls381.VerifyingKey
		if err := groth16_bls381.Setup(_r1cs, &pk, &vk); err != nil {
			return nil, nil, err
		}
		return &pk, &vk, nil
	case *backend_bn256.R1CS:
		var pk groth16_bn256.ProvingKey
		var vk groth16_bn256.VerifyingKey
		if err := groth16_bn256.Setup(_r1cs, &pk, &vk); err != nil {
			return nil, nil, err
		}
		return &pk, &vk, nil
	case *backend_bw761.R1CS:
		var pk groth16_bw761.ProvingKey
		var vk groth16_bw761.VerifyingKey
		if err := groth16_bw761.Setup(_r1cs, &pk, &vk); err != nil {
			return nil, nil, err
		}
		return &pk, &vk, nil
	default:
		panic("unrecognized R1CS curve type")
	}
}

// DummySetup create a random ProvingKey with provided R1CS
// it doesn't return a VerifyingKey and is use for benchmarking or test purposes only.
func DummySetup(r1cs backend.ConstraintSystem) (ProvingKey, error) {
	switch _r1cs := r1cs.(type) {
	case *backend_bls377.R1CS:
		var pk groth16_bls377.ProvingKey
		if err := groth16_bls377.DummySetup(_r1cs, &pk); err != nil {
			return nil, err
		}
		return &pk, nil
	case *backend_bls381.R1CS:
		var pk groth16_bls381.ProvingKey
		if err := groth16_bls381.DummySetup(_r1cs, &pk); err != nil {
			return nil, err
		}
		return &pk, nil
	case *backend_bn256.R1CS:
		var pk groth16_bn256.ProvingKey
		if err := groth16_bn256.DummySetup(_r1cs, &pk); err != nil {
			return nil, err
		}
		return &pk, nil
	case *backend_bw761.R1CS:
		var pk groth16_bw761.ProvingKey
		if err := groth16_bw761.DummySetup(_r1cs, &pk); err != nil {
			return nil, err
		}
		return &pk, nil
	default:
		panic("unrecognized R1CS curve type")
	}
}

// NewProvingKey instantiates a curve-typed ProvingKey and returns an interface object
// This function exists for serialization purposes
func NewProvingKey(curveID gurvy.ID) ProvingKey {
	var pk ProvingKey
	switch curveID {
	case gurvy.BN256:
		pk = &groth16_bn256.ProvingKey{}
	case gurvy.BLS377:
		pk = &groth16_bls377.ProvingKey{}
	case gurvy.BLS381:
		pk = &groth16_bls381.ProvingKey{}
	case gurvy.BW761:
		pk = &groth16_bw761.ProvingKey{}
	default:
		panic("not implemented")
	}
	return pk
}

// NewVerifyingKey instantiates a curve-typed VerifyingKey and returns an interface
// This function exists for serialization purposes
func NewVerifyingKey(curveID gurvy.ID) VerifyingKey {
	var vk VerifyingKey
	switch curveID {
	case gurvy.BN256:
		vk = &groth16_bn256.VerifyingKey{}
	case gurvy.BLS377:
		vk = &groth16_bls377.VerifyingKey{}
	case gurvy.BLS381:
		vk = &groth16_bls381.VerifyingKey{}
	case gurvy.BW761:
		vk = &groth16_bw761.VerifyingKey{}
	default:
		panic("not implemented")
	}

	return vk
}

// NewProof instantiates a curve-typed Proof and returns an interface
// This function exists for serialization purposes
func NewProof(curveID gurvy.ID) Proof {
	var proof Proof
	switch curveID {
	case gurvy.BN256:
		proof = &groth16_bn256.Proof{}
	case gurvy.BLS377:
		proof = &groth16_bls377.Proof{}
	case gurvy.BLS381:
		proof = &groth16_bls381.Proof{}
	case gurvy.BW761:
		proof = &groth16_bw761.Proof{}
	default:
		panic("not implemented")
	}

	return proof
}

// NewCS instantiate a concrete curved-typed R1CS and return a R1CS interface
// This method exists for (de)serialization purposes
func NewCS(curveID gurvy.ID) backend.ConstraintSystem {
	var r1cs backend.ConstraintSystem
	switch curveID {
	case gurvy.BN256:
		r1cs = &backend_bn256.R1CS{}
	case gurvy.BLS377:
		r1cs = &backend_bls377.R1CS{}
	case gurvy.BLS381:
		r1cs = &backend_bls381.R1CS{}
	case gurvy.BW761:
		r1cs = &backend_bw761.R1CS{}
	default:
		panic("not implemented")
	}
	return r1cs
}
